/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package io.moov.sdk.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import io.moov.sdk.utils.Utils;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.util.Optional;

/**
 * PartnerFees
 * 
 * <p>Monthly partner costs that are charged separately and not included in residual subtotal (e.g.
 * platform fees, minimums).
 */
public class PartnerFees {
    /**
     * The minimum spending amount that must be met in the billing period. If actual usage is below the
     * minimum amount, account is charged the difference.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("minimumCommitment")
    private Optional<? extends BillingCountAndAmount> minimumCommitment;

    /**
     * Fixed recurring fee for the billing period regardless of usage.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("monthlyPlatform")
    private Optional<? extends BillingCountAndAmount> monthlyPlatform;

    /**
     * Total partner fees.
     */
    @JsonProperty("total")
    private BillingCountAndAmount total;

    @JsonCreator
    public PartnerFees(
            @JsonProperty("minimumCommitment") Optional<? extends BillingCountAndAmount> minimumCommitment,
            @JsonProperty("monthlyPlatform") Optional<? extends BillingCountAndAmount> monthlyPlatform,
            @JsonProperty("total") BillingCountAndAmount total) {
        Utils.checkNotNull(minimumCommitment, "minimumCommitment");
        Utils.checkNotNull(monthlyPlatform, "monthlyPlatform");
        Utils.checkNotNull(total, "total");
        this.minimumCommitment = minimumCommitment;
        this.monthlyPlatform = monthlyPlatform;
        this.total = total;
    }
    
    public PartnerFees(
            BillingCountAndAmount total) {
        this(Optional.empty(), Optional.empty(), total);
    }

    /**
     * The minimum spending amount that must be met in the billing period. If actual usage is below the
     * minimum amount, account is charged the difference.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BillingCountAndAmount> minimumCommitment() {
        return (Optional<BillingCountAndAmount>) minimumCommitment;
    }

    /**
     * Fixed recurring fee for the billing period regardless of usage.
     */
    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BillingCountAndAmount> monthlyPlatform() {
        return (Optional<BillingCountAndAmount>) monthlyPlatform;
    }

    /**
     * Total partner fees.
     */
    @JsonIgnore
    public BillingCountAndAmount total() {
        return total;
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The minimum spending amount that must be met in the billing period. If actual usage is below the
     * minimum amount, account is charged the difference.
     */
    public PartnerFees withMinimumCommitment(BillingCountAndAmount minimumCommitment) {
        Utils.checkNotNull(minimumCommitment, "minimumCommitment");
        this.minimumCommitment = Optional.ofNullable(minimumCommitment);
        return this;
    }


    /**
     * The minimum spending amount that must be met in the billing period. If actual usage is below the
     * minimum amount, account is charged the difference.
     */
    public PartnerFees withMinimumCommitment(Optional<? extends BillingCountAndAmount> minimumCommitment) {
        Utils.checkNotNull(minimumCommitment, "minimumCommitment");
        this.minimumCommitment = minimumCommitment;
        return this;
    }

    /**
     * Fixed recurring fee for the billing period regardless of usage.
     */
    public PartnerFees withMonthlyPlatform(BillingCountAndAmount monthlyPlatform) {
        Utils.checkNotNull(monthlyPlatform, "monthlyPlatform");
        this.monthlyPlatform = Optional.ofNullable(monthlyPlatform);
        return this;
    }


    /**
     * Fixed recurring fee for the billing period regardless of usage.
     */
    public PartnerFees withMonthlyPlatform(Optional<? extends BillingCountAndAmount> monthlyPlatform) {
        Utils.checkNotNull(monthlyPlatform, "monthlyPlatform");
        this.monthlyPlatform = monthlyPlatform;
        return this;
    }

    /**
     * Total partner fees.
     */
    public PartnerFees withTotal(BillingCountAndAmount total) {
        Utils.checkNotNull(total, "total");
        this.total = total;
        return this;
    }

    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        PartnerFees other = (PartnerFees) o;
        return 
            Utils.enhancedDeepEquals(this.minimumCommitment, other.minimumCommitment) &&
            Utils.enhancedDeepEquals(this.monthlyPlatform, other.monthlyPlatform) &&
            Utils.enhancedDeepEquals(this.total, other.total);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            minimumCommitment, monthlyPlatform, total);
    }
    
    @Override
    public String toString() {
        return Utils.toString(PartnerFees.class,
                "minimumCommitment", minimumCommitment,
                "monthlyPlatform", monthlyPlatform,
                "total", total);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private Optional<? extends BillingCountAndAmount> minimumCommitment = Optional.empty();

        private Optional<? extends BillingCountAndAmount> monthlyPlatform = Optional.empty();

        private BillingCountAndAmount total;

        private Builder() {
          // force use of static builder() method
        }


        /**
         * The minimum spending amount that must be met in the billing period. If actual usage is below the
         * minimum amount, account is charged the difference.
         */
        public Builder minimumCommitment(BillingCountAndAmount minimumCommitment) {
            Utils.checkNotNull(minimumCommitment, "minimumCommitment");
            this.minimumCommitment = Optional.ofNullable(minimumCommitment);
            return this;
        }

        /**
         * The minimum spending amount that must be met in the billing period. If actual usage is below the
         * minimum amount, account is charged the difference.
         */
        public Builder minimumCommitment(Optional<? extends BillingCountAndAmount> minimumCommitment) {
            Utils.checkNotNull(minimumCommitment, "minimumCommitment");
            this.minimumCommitment = minimumCommitment;
            return this;
        }


        /**
         * Fixed recurring fee for the billing period regardless of usage.
         */
        public Builder monthlyPlatform(BillingCountAndAmount monthlyPlatform) {
            Utils.checkNotNull(monthlyPlatform, "monthlyPlatform");
            this.monthlyPlatform = Optional.ofNullable(monthlyPlatform);
            return this;
        }

        /**
         * Fixed recurring fee for the billing period regardless of usage.
         */
        public Builder monthlyPlatform(Optional<? extends BillingCountAndAmount> monthlyPlatform) {
            Utils.checkNotNull(monthlyPlatform, "monthlyPlatform");
            this.monthlyPlatform = monthlyPlatform;
            return this;
        }


        /**
         * Total partner fees.
         */
        public Builder total(BillingCountAndAmount total) {
            Utils.checkNotNull(total, "total");
            this.total = total;
            return this;
        }

        public PartnerFees build() {

            return new PartnerFees(
                minimumCommitment, monthlyPlatform, total);
        }

    }
}
