/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package io.moov.openapi;

import com.fasterxml.jackson.core.type.TypeReference;
import io.moov.openapi.models.components.BankAccount;
import io.moov.openapi.models.components.BankAccountVerification;
import io.moov.openapi.models.components.BankAccountVerificationCreated;
import io.moov.openapi.models.components.BankAccountWaitFor;
import io.moov.openapi.models.components.CompleteBankAccountVerification;
import io.moov.openapi.models.components.CompleteMicroDeposits;
import io.moov.openapi.models.components.CompletedMicroDeposits;
import io.moov.openapi.models.components.LinkBankAccount;
import io.moov.openapi.models.components.Versions;
import io.moov.openapi.models.errors.APIException;
import io.moov.openapi.models.errors.BankAccountValidationError;
import io.moov.openapi.models.errors.GenericError;
import io.moov.openapi.models.errors.MicroDepositValidationError;
import io.moov.openapi.models.operations.CompleteBankAccountVerificationRequest;
import io.moov.openapi.models.operations.CompleteBankAccountVerificationRequestBuilder;
import io.moov.openapi.models.operations.CompleteBankAccountVerificationResponse;
import io.moov.openapi.models.operations.CompleteBankAccountVerificationSecurity;
import io.moov.openapi.models.operations.CompleteMicroDepositsRequest;
import io.moov.openapi.models.operations.CompleteMicroDepositsRequestBuilder;
import io.moov.openapi.models.operations.CompleteMicroDepositsResponse;
import io.moov.openapi.models.operations.CompleteMicroDepositsSecurity;
import io.moov.openapi.models.operations.DisableBankAccountRequest;
import io.moov.openapi.models.operations.DisableBankAccountRequestBuilder;
import io.moov.openapi.models.operations.DisableBankAccountResponse;
import io.moov.openapi.models.operations.DisableBankAccountSecurity;
import io.moov.openapi.models.operations.GetBankAccountRequest;
import io.moov.openapi.models.operations.GetBankAccountRequestBuilder;
import io.moov.openapi.models.operations.GetBankAccountResponse;
import io.moov.openapi.models.operations.GetBankAccountSecurity;
import io.moov.openapi.models.operations.GetBankAccountVerificationRequest;
import io.moov.openapi.models.operations.GetBankAccountVerificationRequestBuilder;
import io.moov.openapi.models.operations.GetBankAccountVerificationResponse;
import io.moov.openapi.models.operations.GetBankAccountVerificationSecurity;
import io.moov.openapi.models.operations.InitiateBankAccountVerificationRequest;
import io.moov.openapi.models.operations.InitiateBankAccountVerificationRequestBuilder;
import io.moov.openapi.models.operations.InitiateBankAccountVerificationResponse;
import io.moov.openapi.models.operations.InitiateBankAccountVerificationSecurity;
import io.moov.openapi.models.operations.InitiateMicroDepositsRequest;
import io.moov.openapi.models.operations.InitiateMicroDepositsRequestBuilder;
import io.moov.openapi.models.operations.InitiateMicroDepositsResponse;
import io.moov.openapi.models.operations.InitiateMicroDepositsSecurity;
import io.moov.openapi.models.operations.LinkBankAccountRequest;
import io.moov.openapi.models.operations.LinkBankAccountRequestBuilder;
import io.moov.openapi.models.operations.LinkBankAccountResponse;
import io.moov.openapi.models.operations.LinkBankAccountSecurity;
import io.moov.openapi.models.operations.ListBankAccountsRequest;
import io.moov.openapi.models.operations.ListBankAccountsRequestBuilder;
import io.moov.openapi.models.operations.ListBankAccountsResponse;
import io.moov.openapi.models.operations.ListBankAccountsSecurity;
import io.moov.openapi.models.operations.SDKMethodInterfaces.*;
import io.moov.openapi.utils.HTTPClient;
import io.moov.openapi.utils.HTTPRequest;
import io.moov.openapi.utils.Hook.AfterErrorContextImpl;
import io.moov.openapi.utils.Hook.AfterSuccessContextImpl;
import io.moov.openapi.utils.Hook.BeforeRequestContextImpl;
import io.moov.openapi.utils.SerializedBody;
import io.moov.openapi.utils.Utils.JsonShape;
import io.moov.openapi.utils.Utils;
import java.io.InputStream;
import java.lang.Exception;
import java.lang.Object;
import java.lang.String;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.List;
import java.util.Optional; 

public class BankAccounts implements
            MethodCallLinkBankAccount,
            MethodCallListBankAccounts,
            MethodCallGetBankAccount,
            MethodCallDisableBankAccount,
            MethodCallInitiateMicroDeposits,
            MethodCallCompleteMicroDeposits,
            MethodCallGetBankAccountVerification,
            MethodCallInitiateBankAccountVerification,
            MethodCallCompleteBankAccountVerification {

    private final SDKConfiguration sdkConfiguration;

    BankAccounts(SDKConfiguration sdkConfiguration) {
        this.sdkConfiguration = sdkConfiguration;
    }


    /**
     * Link a bank account to an existing Moov account. Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/). -  - It is strongly recommended that callers include the `X-Wait-For` header, set to `payment-method`, if the newly linked - bank-account is intended to be used right away. If this header is not included, the caller will need to poll the [List Payment - Methods](https://docs.moov.io/api/sources/payment-methods/list/) - endpoint to wait for the new payment methods to be available for use.
     * @return The call builder
     */
    public LinkBankAccountRequestBuilder linkBankAccount() {
        return new LinkBankAccountRequestBuilder(this);
    }

    /**
     * Link a bank account to an existing Moov account. Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/). -  - It is strongly recommended that callers include the `X-Wait-For` header, set to `payment-method`, if the newly linked - bank-account is intended to be used right away. If this header is not included, the caller will need to poll the [List Payment - Methods](https://docs.moov.io/api/sources/payment-methods/list/) - endpoint to wait for the new payment methods to be available for use.
     * @param security The security details to use for authentication.
     * @param accountID
     * @param linkBankAccount
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public LinkBankAccountResponse linkBankAccount(
            LinkBankAccountSecurity security,
            String accountID,
            LinkBankAccount linkBankAccount) throws Exception {
        return linkBankAccount(security, Optional.empty(), Optional.empty(), accountID, linkBankAccount);
    }
    
    /**
     * Link a bank account to an existing Moov account. Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/). -  - It is strongly recommended that callers include the `X-Wait-For` header, set to `payment-method`, if the newly linked - bank-account is intended to be used right away. If this header is not included, the caller will need to poll the [List Payment - Methods](https://docs.moov.io/api/sources/payment-methods/list/) - endpoint to wait for the new payment methods to be available for use.
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param xWaitFor
     * @param accountID
     * @param linkBankAccount
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public LinkBankAccountResponse linkBankAccount(
            LinkBankAccountSecurity security,
            Optional<? extends Versions> xMoovVersion,
            Optional<? extends BankAccountWaitFor> xWaitFor,
            String accountID,
            LinkBankAccount linkBankAccount) throws Exception {
        LinkBankAccountRequest request =
            LinkBankAccountRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .xWaitFor(xWaitFor)
                .accountID(accountID)
                .linkBankAccount(linkBankAccount)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                LinkBankAccountRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "linkBankAccount",
                "json",
                false);
        if (_serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "linkBankAccount", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "422", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "linkBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "linkBankAccount",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "linkBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        LinkBankAccountResponse.Builder _resBuilder = 
            LinkBankAccountResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        LinkBankAccountResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccount _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccount>() {});
                _res.withBankAccount(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccountValidationError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccountValidationError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * List all the bank accounts associated with a particular Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this endpoint  - from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public ListBankAccountsRequestBuilder listBankAccounts() {
        return new ListBankAccountsRequestBuilder(this);
    }

    /**
     * List all the bank accounts associated with a particular Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this endpoint  - from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListBankAccountsResponse listBankAccounts(
            ListBankAccountsSecurity security,
            String accountID) throws Exception {
        return listBankAccounts(security, Optional.empty(), accountID);
    }
    
    /**
     * List all the bank accounts associated with a particular Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this endpoint  - from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public ListBankAccountsResponse listBankAccounts(
            ListBankAccountsSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID) throws Exception {
        ListBankAccountsRequest request =
            ListBankAccountsRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                ListBankAccountsRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "listBankAccounts", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "listBankAccounts",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "listBankAccounts",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "listBankAccounts",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        ListBankAccountsResponse.Builder _resBuilder = 
            ListBankAccountsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        ListBankAccountsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                List<BankAccount> _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<List<BankAccount>>() {});
                _res.withBankAccounts(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Retrieve bank account details (i.e. routing number or account type) associated with a specific Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this  - endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public GetBankAccountRequestBuilder getBankAccount() {
        return new GetBankAccountRequestBuilder(this);
    }

    /**
     * Retrieve bank account details (i.e. routing number or account type) associated with a specific Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this  - endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetBankAccountResponse getBankAccount(
            GetBankAccountSecurity security,
            String accountID,
            String bankAccountID) throws Exception {
        return getBankAccount(security, Optional.empty(), accountID, bankAccountID);
    }
    
    /**
     * Retrieve bank account details (i.e. routing number or account type) associated with a specific Moov account.  -  - Read our [bank accounts guide](https://docs.moov.io/guides/sources/bank-accounts/) to learn more. To use this  - endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetBankAccountResponse getBankAccount(
            GetBankAccountSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID) throws Exception {
        GetBankAccountRequest request =
            GetBankAccountRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetBankAccountRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "getBankAccount", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "getBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "getBankAccount",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "getBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetBankAccountResponse.Builder _resBuilder = 
            GetBankAccountResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetBankAccountResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccount _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccount>() {});
                _res.withBankAccount(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Discontinue using a specified bank account linked to a Moov account.  -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope  - when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public DisableBankAccountRequestBuilder disableBankAccount() {
        return new DisableBankAccountRequestBuilder(this);
    }

    /**
     * Discontinue using a specified bank account linked to a Moov account.  -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope  - when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public DisableBankAccountResponse disableBankAccount(
            DisableBankAccountSecurity security,
            String accountID,
            String bankAccountID) throws Exception {
        return disableBankAccount(security, Optional.empty(), accountID, bankAccountID);
    }
    
    /**
     * Discontinue using a specified bank account linked to a Moov account.  -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope  - when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public DisableBankAccountResponse disableBankAccount(
            DisableBankAccountSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID) throws Exception {
        DisableBankAccountRequest request =
            DisableBankAccountRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                DisableBankAccountRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "DELETE");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "disableBankAccount", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "disableBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "disableBankAccount",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "disableBankAccount",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        DisableBankAccountResponse.Builder _resBuilder = 
            DisableBankAccountResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        DisableBankAccountResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "204")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Micro-deposits help confirm bank account ownership, helping reduce fraud and the risk of unauthorized activity. Use this method to initiate the micro-deposit verification, sending two small credit transfers to the bank account you want to confirm. -  - If you request micro-deposits before 4:15PM ET, they will appear that same day. If you request micro-deposits any time after 4:15PM ET, they will appear the next banking day. When the two credits are initiated, Moov simultaneously initiates a debit to recoup the micro-deposits.  -  - `sandbox` - Micro-deposits initiated for a `sandbox` bank account will always be `$0.00` / `$0.00` and instantly verifiable once initiated. -  - You can simulate micro-deposit verification in test mode. See our [test mode](https://docs.moov.io/guides/get-started/test-mode/#micro-deposits) guide for more information. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public InitiateMicroDepositsRequestBuilder initiateMicroDeposits() {
        return new InitiateMicroDepositsRequestBuilder(this);
    }

    /**
     * Micro-deposits help confirm bank account ownership, helping reduce fraud and the risk of unauthorized activity. Use this method to initiate the micro-deposit verification, sending two small credit transfers to the bank account you want to confirm. -  - If you request micro-deposits before 4:15PM ET, they will appear that same day. If you request micro-deposits any time after 4:15PM ET, they will appear the next banking day. When the two credits are initiated, Moov simultaneously initiates a debit to recoup the micro-deposits.  -  - `sandbox` - Micro-deposits initiated for a `sandbox` bank account will always be `$0.00` / `$0.00` and instantly verifiable once initiated. -  - You can simulate micro-deposit verification in test mode. See our [test mode](https://docs.moov.io/guides/get-started/test-mode/#micro-deposits) guide for more information. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public InitiateMicroDepositsResponse initiateMicroDeposits(
            InitiateMicroDepositsSecurity security,
            String accountID,
            String bankAccountID) throws Exception {
        return initiateMicroDeposits(security, Optional.empty(), accountID, bankAccountID);
    }
    
    /**
     * Micro-deposits help confirm bank account ownership, helping reduce fraud and the risk of unauthorized activity. Use this method to initiate the micro-deposit verification, sending two small credit transfers to the bank account you want to confirm. -  - If you request micro-deposits before 4:15PM ET, they will appear that same day. If you request micro-deposits any time after 4:15PM ET, they will appear the next banking day. When the two credits are initiated, Moov simultaneously initiates a debit to recoup the micro-deposits.  -  - `sandbox` - Micro-deposits initiated for a `sandbox` bank account will always be `$0.00` / `$0.00` and instantly verifiable once initiated. -  - You can simulate micro-deposit verification in test mode. See our [test mode](https://docs.moov.io/guides/get-started/test-mode/#micro-deposits) guide for more information. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public InitiateMicroDepositsResponse initiateMicroDeposits(
            InitiateMicroDepositsSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID) throws Exception {
        InitiateMicroDepositsRequest request =
            InitiateMicroDepositsRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                InitiateMicroDepositsRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}/micro-deposits",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "initiateMicroDeposits", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "initiateMicroDeposits",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "initiateMicroDeposits",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "initiateMicroDeposits",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        InitiateMicroDepositsResponse.Builder _resBuilder = 
            InitiateMicroDepositsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        InitiateMicroDepositsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "204")) {
            // no content 
            return _res;
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Complete the micro-deposit validation process by passing the amounts of the two transfers within three tries. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public CompleteMicroDepositsRequestBuilder completeMicroDeposits() {
        return new CompleteMicroDepositsRequestBuilder(this);
    }

    /**
     * Complete the micro-deposit validation process by passing the amounts of the two transfers within three tries. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @param completeMicroDeposits Request to complete the micro-deposit verification workflow.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CompleteMicroDepositsResponse completeMicroDeposits(
            CompleteMicroDepositsSecurity security,
            String accountID,
            String bankAccountID,
            CompleteMicroDeposits completeMicroDeposits) throws Exception {
        return completeMicroDeposits(security, Optional.empty(), accountID, bankAccountID, completeMicroDeposits);
    }
    
    /**
     * Complete the micro-deposit validation process by passing the amounts of the two transfers within three tries. -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @param completeMicroDeposits Request to complete the micro-deposit verification workflow.
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CompleteMicroDepositsResponse completeMicroDeposits(
            CompleteMicroDepositsSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID,
            CompleteMicroDeposits completeMicroDeposits) throws Exception {
        CompleteMicroDepositsRequest request =
            CompleteMicroDepositsRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .completeMicroDeposits(completeMicroDeposits)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CompleteMicroDepositsRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}/micro-deposits",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PUT");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "completeMicroDeposits",
                "json",
                false);
        if (_serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "completeMicroDeposits", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "422", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "completeMicroDeposits",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "completeMicroDeposits",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "completeMicroDeposits",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CompleteMicroDepositsResponse.Builder _resBuilder = 
            CompleteMicroDepositsResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CompleteMicroDepositsResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                CompletedMicroDeposits _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<CompletedMicroDeposits>() {});
                _res.withCompletedMicroDeposits(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                MicroDepositValidationError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<MicroDepositValidationError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Retrieve the current status and details of an instant verification, including whether the verification method was instant or same-day  - ACH. This helps track the verification process in real-time and provides details in case of exceptions. -  - The status will indicate the following: -  - - `new`: Verification initiated, credit pending to the payment network - - `sent-credit`: Credit sent, available for verification - - `failed`: Verification failed, description provided, user needs to add a new bank account - - `expired`: Verification expired after 14 days, initiate another verification - - `max-attempts-exceeded`: Five incorrect code attempts exhausted, initiate another verification -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public GetBankAccountVerificationRequestBuilder getBankAccountVerification() {
        return new GetBankAccountVerificationRequestBuilder(this);
    }

    /**
     * Retrieve the current status and details of an instant verification, including whether the verification method was instant or same-day  - ACH. This helps track the verification process in real-time and provides details in case of exceptions. -  - The status will indicate the following: -  - - `new`: Verification initiated, credit pending to the payment network - - `sent-credit`: Credit sent, available for verification - - `failed`: Verification failed, description provided, user needs to add a new bank account - - `expired`: Verification expired after 14 days, initiate another verification - - `max-attempts-exceeded`: Five incorrect code attempts exhausted, initiate another verification -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetBankAccountVerificationResponse getBankAccountVerification(
            GetBankAccountVerificationSecurity security,
            String accountID,
            String bankAccountID) throws Exception {
        return getBankAccountVerification(security, Optional.empty(), accountID, bankAccountID);
    }
    
    /**
     * Retrieve the current status and details of an instant verification, including whether the verification method was instant or same-day  - ACH. This helps track the verification process in real-time and provides details in case of exceptions. -  - The status will indicate the following: -  - - `new`: Verification initiated, credit pending to the payment network - - `sent-credit`: Credit sent, available for verification - - `failed`: Verification failed, description provided, user needs to add a new bank account - - `expired`: Verification expired after 14 days, initiate another verification - - `max-attempts-exceeded`: Five incorrect code attempts exhausted, initiate another verification -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.read` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public GetBankAccountVerificationResponse getBankAccountVerification(
            GetBankAccountVerificationSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID) throws Exception {
        GetBankAccountVerificationRequest request =
            GetBankAccountVerificationRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                GetBankAccountVerificationRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}/verify",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "GET");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "getBankAccountVerification", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "getBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "getBankAccountVerification",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "getBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        GetBankAccountVerificationResponse.Builder _resBuilder = 
            GetBankAccountVerificationResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        GetBankAccountVerificationResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccountVerification _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccountVerification>() {});
                _res.withBankAccountVerification(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Instant micro-deposit verification offers a quick and efficient way to verify bank account ownership.  -  - Send a $0.01 credit with a unique verification code via RTP or same-day ACH, depending on the receiving banks capabilities. This - feature provides a faster alternative to traditional methods, allowing verification in a single session. -  - It is recommended to use the `X-Wait-For: rail-response` header to synchronously receive the outcome of the instant credit in the -  response payload. -  - Possible verification methods: -   - `instant`: Real-time verification credit sent via RTP -   - `ach`: Verification credit sent via same-day ACH -  - Possible statuses: -   - `new`: Verification initiated, credit pending -   - `sent-credit`: Credit sent, available for verification in the external bank account -   - `failed`: Verification failed due to credit rejection/return, details in `exceptionDetails` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public InitiateBankAccountVerificationRequestBuilder initiateBankAccountVerification() {
        return new InitiateBankAccountVerificationRequestBuilder(this);
    }

    /**
     * Instant micro-deposit verification offers a quick and efficient way to verify bank account ownership.  -  - Send a $0.01 credit with a unique verification code via RTP or same-day ACH, depending on the receiving banks capabilities. This - feature provides a faster alternative to traditional methods, allowing verification in a single session. -  - It is recommended to use the `X-Wait-For: rail-response` header to synchronously receive the outcome of the instant credit in the -  response payload. -  - Possible verification methods: -   - `instant`: Real-time verification credit sent via RTP -   - `ach`: Verification credit sent via same-day ACH -  - Possible statuses: -   - `new`: Verification initiated, credit pending -   - `sent-credit`: Credit sent, available for verification in the external bank account -   - `failed`: Verification failed due to credit rejection/return, details in `exceptionDetails` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xWaitFor
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public InitiateBankAccountVerificationResponse initiateBankAccountVerification(
            InitiateBankAccountVerificationSecurity security,
            BankAccountWaitFor xWaitFor,
            String accountID,
            String bankAccountID) throws Exception {
        return initiateBankAccountVerification(security, Optional.empty(), xWaitFor, accountID, bankAccountID);
    }
    
    /**
     * Instant micro-deposit verification offers a quick and efficient way to verify bank account ownership.  -  - Send a $0.01 credit with a unique verification code via RTP or same-day ACH, depending on the receiving banks capabilities. This - feature provides a faster alternative to traditional methods, allowing verification in a single session. -  - It is recommended to use the `X-Wait-For: rail-response` header to synchronously receive the outcome of the instant credit in the -  response payload. -  - Possible verification methods: -   - `instant`: Real-time verification credit sent via RTP -   - `ach`: Verification credit sent via same-day ACH -  - Possible statuses: -   - `new`: Verification initiated, credit pending -   - `sent-credit`: Credit sent, available for verification in the external bank account -   - `failed`: Verification failed due to credit rejection/return, details in `exceptionDetails` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when generating a  - [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param xWaitFor
     * @param accountID
     * @param bankAccountID
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public InitiateBankAccountVerificationResponse initiateBankAccountVerification(
            InitiateBankAccountVerificationSecurity security,
            Optional<? extends Versions> xMoovVersion,
            BankAccountWaitFor xWaitFor,
            String accountID,
            String bankAccountID) throws Exception {
        InitiateBankAccountVerificationRequest request =
            InitiateBankAccountVerificationRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .xWaitFor(xWaitFor)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                InitiateBankAccountVerificationRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}/verify",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "POST");
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "initiateBankAccountVerification", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "initiateBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "initiateBankAccountVerification",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "initiateBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        InitiateBankAccountVerificationResponse.Builder _resBuilder = 
            InitiateBankAccountVerificationResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        InitiateBankAccountVerificationResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccountVerificationCreated _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccountVerificationCreated>() {});
                _res.withBankAccountVerificationCreated(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }



    /**
     * Finalize the instant micro-deposit verification by submitting the verification code displayed in the users bank account.  -  - Upon successful verification, the bank account status will be updated to `verified` and eligible for ACH debit transactions. -  - The following formats are accepted: - - `MV0000` - - `mv0000` - - `0000` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @return The call builder
     */
    public CompleteBankAccountVerificationRequestBuilder completeBankAccountVerification() {
        return new CompleteBankAccountVerificationRequestBuilder(this);
    }

    /**
     * Finalize the instant micro-deposit verification by submitting the verification code displayed in the users bank account.  -  - Upon successful verification, the bank account status will be updated to `verified` and eligible for ACH debit transactions. -  - The following formats are accepted: - - `MV0000` - - `mv0000` - - `0000` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param accountID
     * @param bankAccountID
     * @param completeBankAccountVerification
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CompleteBankAccountVerificationResponse completeBankAccountVerification(
            CompleteBankAccountVerificationSecurity security,
            String accountID,
            String bankAccountID,
            CompleteBankAccountVerification completeBankAccountVerification) throws Exception {
        return completeBankAccountVerification(security, Optional.empty(), accountID, bankAccountID, completeBankAccountVerification);
    }
    
    /**
     * Finalize the instant micro-deposit verification by submitting the verification code displayed in the users bank account.  -  - Upon successful verification, the bank account status will be updated to `verified` and eligible for ACH debit transactions. -  - The following formats are accepted: - - `MV0000` - - `mv0000` - - `0000` -  - To use this endpoint from the browser, you'll need to specify the `/accounts/{accountID}/bank-accounts.write` scope when  - generating a [token](https://docs.moov.io/api/authentication/access-tokens/).
     * @param security The security details to use for authentication.
     * @param xMoovVersion Moov API versions. Version strings are formatted as `vYYYY.MM.DD`, except preVerioned and latest.
     * @param accountID
     * @param bankAccountID
     * @param completeBankAccountVerification
     * @return The response from the API call
     * @throws Exception if the API call fails
     */
    public CompleteBankAccountVerificationResponse completeBankAccountVerification(
            CompleteBankAccountVerificationSecurity security,
            Optional<? extends Versions> xMoovVersion,
            String accountID,
            String bankAccountID,
            CompleteBankAccountVerification completeBankAccountVerification) throws Exception {
        CompleteBankAccountVerificationRequest request =
            CompleteBankAccountVerificationRequest
                .builder()
                .xMoovVersion(xMoovVersion)
                .accountID(accountID)
                .bankAccountID(bankAccountID)
                .completeBankAccountVerification(completeBankAccountVerification)
                .build();
        
        String _baseUrl = this.sdkConfiguration.serverUrl;
        String _url = Utils.generateURL(
                CompleteBankAccountVerificationRequest.class,
                _baseUrl,
                "/accounts/{accountID}/bank-accounts/{bankAccountID}/verify",
                request, null);
        
        HTTPRequest _req = new HTTPRequest(_url, "PUT");
        Object _convertedRequest = Utils.convertToShape(
                request, 
                JsonShape.DEFAULT,
                new TypeReference<Object>() {});
        SerializedBody _serializedRequestBody = Utils.serializeRequestBody(
                _convertedRequest, 
                "completeBankAccountVerification",
                "json",
                false);
        if (_serializedRequestBody == null) {
            throw new Exception("Request body is required");
        }
        _req.setBody(Optional.ofNullable(_serializedRequestBody));
        _req.addHeader("Accept", "application/json")
            .addHeader("user-agent", 
                SDKConfiguration.USER_AGENT);
        _req.addHeaders(Utils.getHeadersFromMetadata(request, null));
        
        // hooks will have access to global security options
        // TODO pass the method level security object to hooks (type system doesn't allow 
        // it, would require some reflection work)
        Optional<SecuritySource> _hookSecuritySource = this.sdkConfiguration.securitySource();
        Utils.configureSecurity(_req, security);
        HTTPClient _client = this.sdkConfiguration.defaultClient;
        HttpRequest _r = 
            sdkConfiguration.hooks()
               .beforeRequest(
                  new BeforeRequestContextImpl(
                      "completeBankAccountVerification", 
                      Optional.of(List.of()), 
                      _hookSecuritySource),
                  _req.build());
        HttpResponse<InputStream> _httpRes;
        try {
            _httpRes = _client.send(_r);
            if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "401", "403", "404", "409", "422", "429", "4XX", "500", "504", "5XX")) {
                _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "completeBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource),
                        Optional.of(_httpRes),
                        Optional.empty());
            } else {
                _httpRes = sdkConfiguration.hooks()
                    .afterSuccess(
                        new AfterSuccessContextImpl(
                            "completeBankAccountVerification",
                            Optional.of(List.of()), 
                            _hookSecuritySource),
                         _httpRes);
            }
        } catch (Exception _e) {
            _httpRes = sdkConfiguration.hooks()
                    .afterError(
                        new AfterErrorContextImpl(
                            "completeBankAccountVerification",
                            Optional.of(List.of()),
                            _hookSecuritySource), 
                        Optional.empty(),
                        Optional.of(_e));
        }
        String _contentType = _httpRes
            .headers()
            .firstValue("Content-Type")
            .orElse("application/octet-stream");
        CompleteBankAccountVerificationResponse.Builder _resBuilder = 
            CompleteBankAccountVerificationResponse
                .builder()
                .contentType(_contentType)
                .statusCode(_httpRes.statusCode())
                .rawResponse(_httpRes);

        CompleteBankAccountVerificationResponse _res = _resBuilder.build();
        
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "200")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                BankAccountVerification _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<BankAccountVerification>() {});
                _res.withBankAccountVerification(Optional.ofNullable(_out));
                return _res;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "400", "409", "422")) {
            if (Utils.contentTypeMatches(_contentType, "application/json")) {
                GenericError _out = Utils.mapper().readValue(
                    Utils.toUtf8AndClose(_httpRes.body()),
                    new TypeReference<GenericError>() {});
                throw _out;
            } else {
                throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "Unexpected content-type received: " + _contentType, 
                    Utils.extractByteArrayFromBody(_httpRes));
            }
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "401", "403", "404", "429", "4XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        if (Utils.statusCodeMatches(_httpRes.statusCode(), "500", "504", "5XX")) {
            // no content 
            throw new APIException(
                    _httpRes, 
                    _httpRes.statusCode(), 
                    "API error occurred", 
                    Utils.extractByteArrayFromBody(_httpRes));
        }
        throw new APIException(
            _httpRes, 
            _httpRes.statusCode(), 
            "Unexpected status code received: " + _httpRes.statusCode(), 
            Utils.extractByteArrayFromBody(_httpRes));
    }

}
